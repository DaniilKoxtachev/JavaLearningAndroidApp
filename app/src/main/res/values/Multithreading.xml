<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="multi_item_1">
         <![CDATA[
<b>Модель памяти Java (Java Memory Model, JMM)</b> описывает поведение потоков в среде исполнения Java. <br>Это часть семантики языка Java, набор правил, описывающий выполнение многопоточных программ и правил, по которым потоки могут взаимодействовать друг с другом посредством основной памяти.<br><br>

Формально модель памяти определяет набор действий межпоточного взаимодействия (эти действия включают в себя, в частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись <b>volatile</b> переменной, запуск нового потока), а также модель памяти определяет отношение между этими действиями <b>-happens-before</b> - абстракции обозначающей, что если операция X связана отношением<b> happens-before</b> с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.<br><br>

Существует несколько основных правил для отношения<b> happens-before</b>:<br>

<b>1)</b>В рамках одного потока любая операция<b> happens-before</b> любой операцией, следующей за ней в исходном коде;<br><br>
<b>2)</b>Освобождение монитора <b>(unlock) happens-before</b> захват того же монитора (lock);<br><br>
<b>3)</b>Выход из <b>synchronized</b> блока/метода <b>happens-before</b> вход в <b>synchronized </b> блок/метод на том же мониторе;<br><br>
<b>4)</b>Запись<b> volatile</b> поля <b>happens-before</b> чтение того же самого <b>volatile</b> поля;<br><br>
<b>5)</b>Завершение метода <b>run()</b> экземпляра класса <b>Thread happens-before</b> выход из метода <b>join()</b> или возвращение <b>false </b>методом<b> isAlive()</b> экземпляром того же потока;<br><br>
<b>6)</b>Вызов метода<b> start() </b>экземпляра класса <b>Thread happens-before</b> начало метода<b> run()</b> экземпляра того же потока;<br><br>
<b>7)</b>Завершение конструктора<b> happens-before</b> начало метода<b> finalize()</b> этого класса;<br><br>
<b>8)</b>Вызов метода<b> interrupt()</b> на потоке<b> happens-before </b>обнаружению потоком факта, что данный метод был вызван либо путем выбрасывания исключения InterruptedException, либо с помощью методов isInterrupted() или interrupted().<br><br>
<b>9)</b>Связь<b>happens-before</b> транзитивна, т.е. если<b> X happens-before Y, а Y happens-before Z, то X happens-before Z</b>.<br><br>
<b>10)</b>Освобождение/захват монитора и запись/чтение в<b> volatile</b> переменную связаны отношением <b>happens-before</b>, только если операции проводятся над одним и тем же экземпляром объекта.<br><br>
<b>11)</b>В отношении <b>happens-before</b> участвуют только два потока, о поведении остальных потоков ничего сказать нельзя, пока в каждом из них не наступит отношение happens-before с другим потоком.<br><br>]]>
    </string>
    <string name="multi_item_2">
      <![CDATA[  Можно выделить несколько основных областей, имеющих отношение к модели памяти:

<b>Видимость (visibility)</b>. Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти, может не увидеть последних изменений поля.<br> И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.<br><br>

       <b> Reordering (переупорядочивание)</b>. Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции.<br> Вернее, с точки зрения потока, наблюдающего за выполнением операций в другом потоке, операции могут быть выполнены не в том порядке, в котором они идут в исходном коде.<br> Тот же эффект может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, а результат второй операции попадает непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью.<br><br> Еще одна причина reordering, может заключаться в том, что процессор может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее.]]>
    </string>
    <string name="multi_item_3">
        <![CDATA[ <b>Потокобезопасность </b> – свойство объекта или кода, которое гарантирует, что при исполнении или использовании несколькими потоками, код будет вести себя, как предполагается.<br> Например потокобезопасный счётчик не пропустит ни один счёт, даже если один и тот же экземпляр этого счётчика будет использоваться несколькими потоками.]]>
    </string>
    <string name="multi_item_4">
         <![CDATA[ <b>Конкуренция </b>— это способ одновременного решения множества задач.<br><br>


Признаки:<br>


<b>1)</b>Наличие нескольких потоков управления (например, Thread в Java, корутина в Kotlin), если поток управления один, то конкурентного выполнения быть не может.<br><br>
<b>2)</b>Недетерминированный результат выполнения. <br> Результат зависит от случайных событий, реализации и того, как была проведена синхронизация.<br> Даже если каждый поток полностью детерминированный, итоговый результат будет недетерминированным<br><br>
<b>Параллелизм</b> — это способ выполнения разных частей одной задачи.<br>

Признаки:<br>

<b>1)</b>Необязательно имеет несколько потоков управления<br><br>
<b>2)</b>Может приводить к детерминированному результату, так, например, результат умножения каждого элемента массива на число, не изменится, если умножать его по частям параллельно.]]>
    </string>
    <string name="multi_item_5">
 <![CDATA[ <b>Кооперативная многозадачность </b> - это способ деления процессорного времени между потоками, при котором каждый поток обязан отдавать управление следующему добровольно.<br><br>

<b>Преимущества такого подхода</b> - простота реализации, меньшие накладные расходы на переключение контекста.<br><br>

<b>Недостатки</b> - если один поток завис или ведет себя некорректно, то зависает целиком вся система и другие потоки никогда не получат управление.]]>
    </string>
    <string name="multi_item_6">
      <![CDATA[   <b>Процесс</b> — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память).<br> Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого.<br> Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие.<br> Это могут быть конвейеры, файлы, каналы связи между компьютерами и многое другое.<br><br>

Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет прямой доступ. <br>Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении.<br> Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.<br><br>

<b>Поток(thread)</b> — определенный способ выполнения процесса, определяющий последовательность исполнения кода в процессе. <br>Потоки всегда создаются в контексте какого-либо процесса, и вся их жизнь проходит только в его границах.<br> Потоки могут исполнять один и тот же код и манипулировать одними и теми же данными, а также совместно использовать описатели объектов ядра, поскольку таблица описателей создается не в отдельных потоках, а в процессах.<br> Так как потоки расходуют существенно меньше ресурсов, чем процессы, в процессе выполнения работы выгоднее создавать дополнительные потоки и избегать создания новых процессов.<br><br>]]>
    </string>
    <string name="multi_item_7">
       <![CDATA[  <b>Зелёные (легковесные) потоки(green threads)</b> - потоки эмулируемые виртуальной машиной или средой исполнения.<br> Создание зелёного потока не подразумевает под собой создание реального потока ОС.<br><br>

Виртуальная машина Java берёт на себя заботу о переключении между разными green threads, а сама машина работает как один поток ОС. <br>Это даёт несколько преимуществ.<br> Потоки ОС относительно дороги в большинстве POSIX-систем.<br> Кроме того, переключение между native threads гораздо медленнее, чем между green threads.<br><br>

Это всё означает, что в некоторых ситуациях green threads гораздо выгоднее, чем native threads.<br> Система может поддерживать гораздо большее количество green threads, чем потоков OС. <br>Например, гораздо практичнее запускать новый green thread для нового HTTP-соединения к веб-серверу, вместо создания нового native thread.<br><br>

Однако есть и недостатки. <br>Самый большой заключается в том, что вы не можете исполнять два потока одновременно. <br>Поскольку существует только один native thread, только он и вызывается планировщиком ОС. <br>Даже если у вас несколько процессоров и несколько green threads, только один процессор может вызывать green thread. <br>И всё потому, что с точки зрения планировщика заданий ОС всё это выглядит одним потоком.<br><br>

Начиная с версии 1.2 Java поддерживает native threads, и с тех пор они используются по умолчанию.<br><br>]]>
    </string>
    <string name="multi_item_8">
      <![CDATA[  1) Создать потомка класса <b>Thread </b>и переопределить его метод<b> run()</b>;<br><br>
2)Создать объект класса <b>Thread</b>, передав ему в конструкторе экземпляр класса, реализующего интерфейс <b>Runnable</b>.<br> Эти интерфейс содержит метод<b> run()</b>, который будет выполняться в новом потоке.<br> Поток закончит выполнение, когда завершится его метод <b>run()</b>.<br><br>
3)Вызвать метод<b> submit()</b> у экземпляра класса реализующего интерфейс <b>ExecutorService</b>, передав ему в качестве параметра экземпляр класса реализующего интерфейс <b>Runnable</b> или <b>Callable </b>(содержит метод <b>call()</b>, в котором описывается логика выполнения).<br><br>]]>
    </string>
    <string name="multi_item_9">
     <![CDATA[  <b> Thread</b> - это класс, некоторая надстройка над физическим потоком.<br><br>

<b>Runnable</b> - это интерфейс, представляющий абстракцию над выполняемой задачей.<br><br>

Помимо того, что <b>Runnable</b> помогает разрешить проблему множественного наследования, несомненный плюс от его использования состоит в том, что он позволяет логически отделить логику выполнения задачи от непосредственного управления потоком.]]>
    </string>
    <string name="multi_item_10">
 <![CDATA[ Несмотря на то, что <b>start()</b> вызывает метод <b>run()</b> внутри себя, это не то же самое, что просто вызов<b> run()</b>.<br> Если <b>run()</b> вызывается как обычный метод, то он вызывается в том же потоке и никакой новый поток не запускается, как это происходит, в случае, когда вы вызываете метод<b> start()</b>.]]>
    </string>
    <string name="multi_item_11">
       <![CDATA[ <b>Никак</b>. <br>В Java не существует абсолютно никакого способа принудительного запуска потока. <br>Это контролируется JVM и Java не предоставляет никакого API для управления этим процессом.]]>
    </string>
    <string name="multi_item_12">
<![CDATA[<b>Синхронизация</b> - это процесс, который позволяет выполнять потоки параллельно.<br><br>

В Java все объекты имеют одну блокировку, благодаря которой только один поток одновременно может получить доступ к критическому коду в объекте.<br> Такая синхронизация помогает предотвратить повреждение состояния объекта.<br> Если поток получил блокировку, ни один другой поток не может войти в синхронизированный код, пока блокировка не будет снята.<br> Когда поток, владеющий блокировкой, выходит из синхронизированного кода, блокировка снимается.
<br>Теперь другой поток может получить блокировку объекта и выполнить синхронизированный код. <br>Если поток пытается получить блокировку объекта, когда другой поток владеет блокировкой, поток переходит в состояние Блокировки до тех пор, пока блокировка не снимется.]]>
    </string>
    <string name="multi_item_13">
<![CDATA[ <b>Системная синхронизация с использованием wait()/notify()</b>. <br>Поток, который ждет выполнения каких-либо условий, вызывает у этого объекта метод<b> wait()</b>, предварительно захватив его монитор.<br> На этом его работа приостанавливается.<br> Другой поток может вызвать на этом же самом объекте метод <b>notify()</b> (опять же, предварительно захватив монитор объекта), в результате чего, ждущий на объекте поток «просыпается» и продолжает свое выполнение.<br> В обоих случаях монитор надо захватывать в явном виде, через <b>synchronized-блок</b>, потому как методы <b>wait()/notify()</b> не синхронизированы!<br><br>

<b>Системная синхронизация с использованием join()</b>. Метод <b>join()</b>, вызванный у экземпляра класса <b>Thread</b>, позволяет текущему потоку остановиться до того момента, как поток, связанный с этим экземпляром, закончит работу.<br><br>

<b>Использование классов из пакета java.util.concurrent</b>, который предоставляет набор классов для организации межпоточного взаимодействия.<br> Примеры таких классов - <b>Lock, Semaphore и пр..</b> <br>Концепция данного подхода заключается в использовании атомарных операций и переменных.]]>
    </string>
    <string name="multi_item_14">
<![CDATA[ Потоки могут находиться в одном из следующих состояний:<br>

<b>1)Новый (New)</b>. После создания экземпляра потока, он находится в состоянии Новый до тех пор, пока не вызван метод start().<br> В этом состоянии поток не считается живым.<br><br>
<b>2)Работоспособный (Runnable)</b>. Поток переходит в состояние Работоспособный, когда вызывается метод start().<br> Поток может перейти в это состояние также из состояния Работающий или из состояния Блокирован.<br> Когда поток находится в этом состоянии, он считается живым.<br><br>
<b>3)Работающий (Running)</b>. Поток переходит из состояния Работоспособный в состояние Работающий, когда Планировщик потоков выбирает его как работающий в данный момент.<br><br>
<b>4)Живой, но не работоспособный (Alive, but not runnable)</b>. Поток может быть живым, но не работоспособным по нескольким причинам:<br><br>
<b>Ожидание (Waiting)</b>. Поток переходит в состояние Ожидания, вызывая метод wait(). <br>Вызов notify() или notifyAll() может перевести поток из состояния Ожидания в состояние Работоспособный.<br><br>
<b>Сон (Sleeping)</b>. Метод sleep() переводит поток в состояние Сна на заданный промежуток времени в миллисекундах.<br><br>
<b>Блокировка (Blocked)</b>. Поток может перейти в это состояние, в ожидании ресурса, такого как ввод/вывод или из-за блокировки другого объекта.<br> В этом случае поток переходит в состояние Работоспособный, когда ресурс становится доступен.<br><br>
<b>Мёртвый (Dead)</b>. Поток считается мёртвым, когда его метод run() полностью выполнен.<br> Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод start().<br><br>]]>
    </string>
    <string name="multi_item_15">
<![CDATA[
Эти методы определены у класса Object и предназначены для взаимодействия потоков между собой при межпоточной синхронизации.<br><br>

<b>wait()</b>: освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()/notifyAll();<br><br>
<b>notify()</b>: продолжает работу потока, у которого ранее был вызван метод wait();<br><br>
<b>notifyAll()</b>: возобновляет работу всех потоков, у которых ранее был вызван метод wait().<br><br>
Когда вызван метод wait(), поток освобождает блокировку на объекте и переходит из состояния Работающий (Running) в состояние Ожидания (Waiting).<br> Метод notify() подаёт сигнал одному из потоков, ожидающих на объекте, чтобы перейти в состояние Работоспособный (Runnable). <br>При этом невозможно определить, какой из ожидающих потоков должен стать работоспособным.<br> Метод notifyAll() заставляет все ожидающие потоки для объекта вернуться в состояние Работоспособный (Runnable).<br> Если ни один поток не находится в ожидании на методе wait(), то при вызове notify() или notifyAll() ничего не происходит.<br><br>

Поток может вызвать методы wait() или notify() для определённого объекта, только если он в данный момент имеет блокировку на этот объект. wait(), notify() и notifyAll() должны вызываться только из синхронизированного кода.]]>
    </string>
    <string name="multi_item_16">
<![CDATA[ Дело в том, что «висеть» на методе wait() одного монитора могут сразу несколько потоков. <br>При вызове notify() только один из них выходит из wait() и пытается захватить монитор, а затем продолжает работу со следующего после wait() оператора.<br> Какой из них выйдет - заранее неизвестно. <br>А при вызове notifyAll(), все висящие на wait() потоки выходят из wait(), и все они пытаются захватить монитор.<br> Понятно, что в любой момент времени монитор может быть захвачен только одним потоком, а остальные ждут своей очереди.<br> Порядок очереди определяется планировщиком потоков Java.<br><br>]]>
    </string>
    <string name="multi_item_17">
<![CDATA[ <b>Метод yield() </b> служит причиной того, что поток переходит из состояния работающий (running) в состояние работоспособный (runnable), давая возможность другим потокам активизироваться. <br>Но следующий выбранный для запуска поток может и не быть другим.<br><br>

<b>Метод sleep()</b> вызывает засыпание текущего потока на заданное время, состояние изменяется с работающий (running) на ожидающий (waiting).<br><br>]]>
    </string>
    <string name="multi_item_18">
     <![CDATA[  <b> Взаимная блокировка (deadlock)</b> - явление, при котором все потоки находятся в режиме ожидания. <br>Происходит, когда достигаются состояния:<br>

<b>Взаимного исключения</b>: по крайней мере один ресурс занят в режиме неделимости и, следовательно, только один поток может использовать ресурс в любой данный момент времени.<br><br>
<b>Удержания и ожидания</b>: поток удерживает как минимум один ресурс и запрашивает дополнительные ресурсов, которые удерживаются другими потоками.<br><br>
<b>Отсутствия предочистки</b>: операционная система не переназначивает ресурсы: если они уже заняты, они должны отдаваться удерживающим потокам сразу же.<br><br>
<b>Цикличного ожидания</b>: поток ждёт освобождения ресурса, другим потоком, который в свою очередь ждёт освобождения ресурса заблокированного первым потоком.<br><br>
Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. <br>Этого можно достичь, получая мониторы разделяемых ресурсов в определённом порядке и освобождая их в обратном порядке.<br><br>]]>
    </string>
    <string name="multi_item_19">
<![CDATA[<b>livelock </b>– тип взаимной блокировки, при котором несколько потоков выполняют бесполезную работу, попадая в зацикленность при попытке получения каких-либо ресурсов.<br> При этом их состояния постоянно изменяются в зависимости друг от друга. <br>Фактической ошибки не возникает, но КПД системы падает до 0. <br>Часто возникает в результате попыток предотвращения deadlock.<br><br>
<b>Реальный пример livelock</b> – когда два человека встречаются в узком коридоре и каждый, пытаясь быть вежливым, отходит в сторону, и так они бесконечно двигаются из стороны в сторону, абсолютно не продвигаясь в нужном им направлении.<br><br>]]>
    </string>
    <string name="multi_item_20">
<![CDATA[ Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет разрешено работать.<br> Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. <br>Практически объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета.<br><br>

Чтобы установить приоритет потока, используется метод класса <b>Thread: final void setPriority(int level)</b>.<br> Значение <b>level</b> изменяется в пределах от <b>Thread.MIN_PRIORITY = 1 </b>до <b>Thread.MAX_PRIORITY = 10</b>. Приоритет по умолчанию -<b> Thread.NORM_PRlORITY = 5</b>.<br><br>]]>
    </string>
    <string name="multi_item_21">
<![CDATA[ <b>Потоки-демоны</b> работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы.<br> Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода<b> setDaemon(boolean value)</b>, вызванного у потока до его запуска.<br><br> Метод <b>boolean isDaemon() </b> позволяет определить, является ли указанный поток демоном или нет.<br> Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще работает.<br><br>]]>
    </string>
    <string name="multi_item_22">
      <![CDATA[ <b> Интерфейс Runnable</b> появился в Java 1.0, а интерфейс <b>Callable</b> был введен в Java 5.0 в составе библиотеки<b> java.util.concurrent</b>;<br><br>
Классы, реализующие интерфейс<b> Runnable </b>для выполнения задачи должны реализовывать метод<b> run()</b>. Классы, реализующие интерфейс <b>Callable - метод call()</b>;<br><br>
Метод <b>Runnable.run()</b> не возвращает никакого значения, <b>Callable.call()</b> возвращает объект<b> Future</b>, который может содержать результат вычислений;<br><br>
Метод <b>run()</b> не может выбрасывать проверяемые исключения, в то время как метод <b>call()</b> может.]]>
    </string>
    <string name="multi_item_23">
 <![CDATA[<b>Semaphore</b> – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор.<br> Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается.<br> Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. <br>Semaphore используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например подключение к базе данных в пуле.<br><br>]]>
    </string>
</resources>