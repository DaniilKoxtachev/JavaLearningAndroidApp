<?xml version="1.0" encoding="utf-8"?>
<resources>
     <string name="sub_item_1">
       <![CDATA[ <b>Объектно-ориентированное программирование (ООП)</b> — методология программирования, основанная на представлении программы в виде совокупности
            объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.<br><br>

            1)Объектно-ориентированное программирование использует в качестве основных логических конструктивных элементов объекты, а не алгоритмы;<br><br>
            2)Каждый объект является экземпляром определенного класса;<br><br>
            3)Классы образуют иерархии.<br><br>

             Программа считается объектно-ориентированной, только если выполнены все три указанных требования. В частности, программирование,
            не использующее наследование, называется не объектно-ориентированным, а программированием с помощью абстрактных типов данных.<br><br>
        Согласно парадигме ООП программа состоит из объектов, обменивающихся сообщениями.<br>
        Объекты могут обладать состоянием, единственный способ изменить состояние объекта - послать ему сообщение, в ответ на которое, объект может изменить собственное состояние.]]>
    </string>

    <string name="sub_item_2">
        <![CDATA[    <b> Инкапсуляция</b> - сокрытие реализации.<br><br>
           <b>Наследование</b> - создание новой сущности на базе уже существующей.<br><br>
           <b> Полиморфизм</b> - возможность иметь разные формы для одной и той же сущности.<br><br>
            <b>Абстракция </b>- набор общих характеристик.<br><br>
            <b>Посылка сообщений</b> - форма связи, взаимодействия между сущностями.<br><br>
           <b> Переиспользование </b>- все что перечислено выше работает на повторное использование кода.<br><br>
            Это единственно верный порядок парадигм ООП, так как каждая последующая использует предыдущие.<br><br>]]>
    </string>

    <string name="sub_item_3">
       <![CDATA[   <b>Инкапсуляция</b>– это свойство системы, позволяющее объединить данные и методы,
        работающие с ними, в классе и скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.<br><br>
         <b>Цель инкапсуляции</b> — уйти от зависимости внешнего интерфейса класса (то, что могут использовать другие классы) от реализации.<br>
        Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.]]>
    </string>

    <string name="sub_item_4">
      <![CDATA[   <b>Наследование</b> – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.<br><br>

    Класс, от которого производится наследование, называется <b>предком, базовым или родительским</b>.<br> <b>Новый класс</b> – потомком, наследником или производным классом.]]>
    </string>
    <string name="sub_item_5">
 <![CDATA[<b>Полиморфизм </b>– это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.<br><br>

        Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного и того же интерфейса для задания единого набора действий.<br>
        Выбор же конкретного действия, в зависимости от ситуации, возлагается на компилятор языка программирования.<br><br>
        Отсюда следует ключевая особенность полиморфизма - <b>использование объекта производного класса, вместо объекта базового</b>
        (потомки могут изменять родительское поведение, даже если обращение к ним будет производиться по ссылке родительского типа).]]>
</string>

    <string name="sub_item_6">
<![CDATA[<b>Абстрагирование</b> – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и незначимые.<br>
        Соответственно, <b>абстракция</b> – это набор всех таких характеристик.]]>
</string>

    <string name="sub_item_7">
<![CDATA[Объекты взаимодействуют, посылая и получая сообщения.<br>
       <b> Сообщение</b> — это запрос на выполнение действия, дополненный набором аргументов, которые могут понадобиться при выполнении действия.<br><br>
        В ООП <b>посылка сообщения (вызов метода)</b> — это единственный путь передать управление объекту.<br><br>
        Если объект должен «отвечать» на это сообщение, то у него должна иметься соответствующий данному сообщению метод.<br><br>
        Так же объекты, используя свои методы, могут и сами посылать сообщения другим объектам.<br>
        Обмен сообщениями реализуется с помощью динамических вызовов, что приводит к чрезвычайно позднему связыванию (extreme late binding).]]>
</string>
    <string name="sub_item_8">
<![CDATA[<b>Класс</b> – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).<br><br>

С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).<br><br>

С точки зрения структуры программы, класс является сложным типом данных.<br><br>

<b>Объект (экземпляр)</b> – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом.<br> Каждый объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе.<br><br>

<b>Интерфейс</b> – это набор методов класса, доступных для использования.<br> Интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов.<br> По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.<br><br>]]>
    </string>

    <string name="sub_item_9">
<![CDATA[
Преимущества:<br>

<b>1)</b>Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира, а не на компьютерную реализацию.<br><br>
<b>2)</b>Классы позволяют проводить конструирование из полезных компонентов, обладающих простыми инструментами, что позволяет абстрагироваться от деталей реализации.<br><br>
<b>3)</b>Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает в случае процедурного программирования, а описываются вместе. <br>Локализация кода и данных улучшает наглядность и удобство сопровождения программного обеспечения.<br><br>
<b>4)</b>Инкапсуляция позволяет привнести свойство модульности, что облегчает распараллеливание выполнения задачи между несколькими исполнителями и обновление версий отдельных компонентов.<br><br>
<b>5)</b>Возможность создавать расширяемые системы.<br><br>
<b>6)</b>Использование полиморфизма оказывается полезным при:<br>
a)Обработке разнородных структур данных.<br> Программы могут работать, не различая вида объектов, что существенно упрощает код.<br> Новые виды могут быть добавлены в любой момент.<br><br>
b)Изменении поведения во время исполнения.<br> На этапе исполнения один объект может быть заменен другим, что позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.<br><br>
c)Реализации работы с наследниками.<br> Алгоритмы можно обобщить настолько, что они уже смогут работать более чем с одним видом объектов.<br><br>
d)Возможности описать независимые от приложения части предметной области в виде набора универсальных классов, или фреймворка, который в дальнейшем будет расширен за счет добавления частей, специфичных для конкретного приложения.<br><br>
<b>7)</b>Повторное использование кода:<br>
a)Сокращается время на разработку, которое может быть отдано другим задачам.<br><br>
b)Компоненты многоразового использования обычно содержат гораздо меньше ошибок, чем вновь разработанные, ведь они уже не раз подвергались проверке.<br><br>
c)Когда некий компонент используется сразу несколькими клиентами, улучшения, вносимые в его код, одновременно оказывают положительное влияние и на множество работающих с ним программ.<br><br>
d)Если программа опирается на стандартные компоненты, ее структура и пользовательский интерфейс становятся более унифицированными, что облегчает ее понимание и упрощает использование.<br><br>
Недостатки:<br>

<b>1)</b>В сложных иерархиях классов поля и методы обычно наследуются с разных уровней.<br> И не всегда легко определить, какие поля и методы фактически относятся к данному классу.<br><br>
<b>2)</b>Код для обработки сообщения иногда «размазан» по многим методам (иначе говоря, обработка сообщения требует не одного, а многих методов, которые могут быть описаны в разных классах).<br><br>
<b>3)</b>Документирование классов - задача более трудная, чем это было в случае процедур и модулей.<br> Поскольку любой метод может быть переопределен, в документации должно говориться не только о том, что делает данный метод, но и о том, в каком контексте он вызывается.<br><br>
<b>4)</b>Неэффективность и неэкономное распределения памяти на этапе выполнения (по причине издержек на динамическое связывание и проверки типов на этапе выполнения).<br><br>
<b>5)</b>Излишняя универсальность.<br> Часто содержится больше методов, чем это реально необходимо текущей программе.<br> А поскольку лишние методы не могут быть удалены, они становятся мертвым грузом.<br><br>]]>
    </string>
</resources>