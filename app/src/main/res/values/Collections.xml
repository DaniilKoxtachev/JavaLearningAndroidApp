<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="coll_item_1">
<![CDATA[<b>«Коллекция»</b> - это структура данных, набор каких-либо объектов.<br>
Данными (объектами в наборе) могут быть числа, строки, объекты пользовательских классов и т.п.]]>
    </string>
    <string name="coll_item_2">
<![CDATA[На вершине иерархии в Java Collection Framework располагаются 2 интерфейса: <b>Collection и Map</b>.<br>Эти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения данных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответственно.<br><br>

Интерфейс Collection расширяют интерфейсы:<br>

1)<b>List (список)</b> представляет собой коллекцию, в которой допустимы дублирующие значения. Реализации:<br><br>
<b>ArrayList </b>- инкапсулирует в себе обычный массив, длина которого автоматически увеличивается при добавлении новых элементов.<br> Элементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.<br><br>
<b>LinkedList (двунаправленный связный список)</b> - состоит из узлов, каждый из которых содержит как собственно данные, так и две ссылки на следующий и предыдущий узел.<br><br>
<b>Vector</b> — реализация динамического массива объектов, методы которой синхронизированы.<br><br>
<b>Stack</b> — реализация стека LIFO (last-in-first-out).<br><br>
<b>Set (сет)</b> описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов. Реализации:<br><br>
<b>HashSet</b> - использует HashMap для хранения данных. <br>В качестве ключа и значения используется добавляемый элемент. <br>Из-за особенностей реализации порядок элементов не гарантируется при добавлении.<br><br>
<b>LinkedHashSet</b> — гарантирует, что порядок элементов при обходе коллекции будет идентичен порядку добавления элементов.<br><br>
<b>TreeSet</b> — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».<br><br>
<b>Queue (очередь)</b> предназначена для хранения элементов с предопределённым способом вставки и извлечения FIFO (first-in-first-out):<br><br>
<b>PriorityQueue</b> — предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».<br><br>
<b>ArrayDeque</b> — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out).<br><br>
Интерфейс<b> Map </b>реализован классами:<br>

<b>Hashtable</b> — хэш-таблица, методы которой синхронизированы. <br>Не позволяет использовать null в качестве значения или ключа и не является упорядоченной.<br><br>
<b>HashMap</b> — хэш-таблица. <br>Позволяет использовать null в качестве значения или ключа и не является упорядоченной.<br><br>
<b>LinkedHashMap</b> — упорядоченная реализация хэш-таблицы.<br><br>
<b>TreeMap</b> — реализация, основанная на красно-чёрных деревьях. <br>Является упорядоченной и предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».<br><br>
<b>WeakHashMap</b> — реализация хэш-таблицы, которая организована с использованием weak references для ключей (сборщик мусора автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ этого элемента нет жёстких ссылок).<br><br>]]>
    </string>
    <string name="coll_item_3">
    <![CDATA[    <b>java.util.Collections</b> - набор статических методов для работы с коллекциями.<br><br>

<b>java.util.Collection </b>- один из основных интерфейсов Java Collections Framework.]]>
    </string>
    <string name="coll_item_4">
  <![CDATA[  <b>fail-fast поведение</b> означает, что при возникновении ошибки или состояния, которое может привести к ошибке, система немедленно прекращает дальнейшую работу и уведомляет об этом.<br> Использование <b>fail-fast</b> подхода позволяет избежать недетерминированного поведения программы в течение времени.<br><br>

В Java Collections API некоторые итераторы ведут себя как<b> fail-fast</b> и выбрасывают <b>ConcurrentModificationException</b>, если после его создания была произведена модификация коллекции, т.е. добавлен или удален элемент напрямую из коллекции, а не используя методы итератора.<br><br>

Реализация такого поведения осуществляется за счет подсчета количества модификаций коллекции <b>(modification count)</b>:<br>

<b>1)</b>при изменении коллекции счетчик модификаций так же изменяется;<br><br>
<b>2)</b>при создании итератора ему передается текущее значение счетчика;<br><br>
<b>3)</b>при каждом обращении к итератору сохраненное значение счетчика сравнивается с текущим, и, если они не совпадают, возникает исключение.]]>
    </string>
    <string name="coll_item_5">
<![CDATA[ В противоположность <b>fail-fast</b>, итераторы <b>fail-safe</b> не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.]]>
    </string>
    <string name="coll_item_6">
<![CDATA[
<b>ArrayList</b> это список, реализованный на основе массива, а <b>LinkedList</b> — это классический двусвязный список, основанный на объектах с ссылками между ними.<br>
<br>
<b> ArrayList:</b><br>

<b>1)</b>доступ к произвольному элементу по индексу за константное время O(1);<br>
<b>2)</b>доступ к элементам по значению за линейное время O(N);<br>
<b>3)</b>вставка в конец в среднем производится за константное время O(1);<br>
<b>4)</b>удаление произвольного элемента из списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку влево (реальный размер массива (capacity) не изменяется);<br>
<b>5)</b>вставка элемента в произвольное место списка занимает значительное время т.к. при этом все элементы, находящиеся «правее» смещаются на одну ячейку вправо;<br>
<b>6)</b>минимум накладных расходов при хранении.<br><br>
<b> LinkedList:</b><br>

<b>1)</b>на получение элемента по индексу или значению потребуется линейное время O(N);<br>
<b>2)</b>на добавление и удаление в начало или конец списка потребуется константное O(1);<br>
<b>3)</b>вставка или удаление в/из произвольного место константное O(1);<br>
<b>4)</b>требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка.<br><br>
В целом,<b> LinkedList</b> в абсолютных величинах проигрывает<b> ArrayList</b> и по потребляемой памяти, и по скорости выполнения операций. <b> LinkedList </b>предпочтительно применять, когда нужны частые операции вставки/удаления или в случаях, когда необходимо гарантированное время добавления элемента в список.]]>

    </string>
    <string name="coll_item_7">
<![CDATA[При удалении произвольного элемента из списка, все элементы, находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак.<br><br> Механизм автоматического «расширения» массива существует, а вот автоматического «сжатия» нет, можно только явно выполнить «сжатие» командой<b> trimToSize()</b>.]]>
    </string>
    <string name="coll_item_8">
     <![CDATA[  <b>IdentityHashMap</b> - это структура данных, так же реализующая интерфейс Map и использующая при сравнении ключей (значений) сравнение ссылок, а не вызов метода equals().<br> Другими словами, в <b>IdentityHashMap</b> два ключа k1 и k2 будут считаться равными, если они указывают на один объект, т.е. выполняется условие k1 == k2.<br><br>

<b>IdentityHashMap</b> не использует метод hashCode(), вместо которого применяется метод <b>System.identityHashCode()</b>, по этой причине <b>IdentityHashMap </b>по сравнению с HashMap имеет более высокую производительность, особенно если последний хранит объекты с дорогостоящими методами equals() и hashCode().<br><br>

Одним из основных требований к использованию<b> HashMap </b> является неизменяемость ключа, а, т.к.<b> IdentityHashMap</b> не использует методы </b>equals() и hashCode()</b>, то это правило на него не распространяется.<br><br>

<b>IdentityHashMap</b> может применяться для реализации сериализации/клонирования. <br> При выполнении подобных алгоритмов программе необходимо обслуживать хэш-таблицу со всеми ссылками на объекты, которые уже были обработаны.<br> Такая структура не должна рассматривать уникальные объекты как равные, даже если метод equals() возвращает true.]]>
    </string>
    <string name="coll_item_9">
<![CDATA[ <b>WeakHashMap</b> - это структура данных, реализующая интерфейс Map и основанная на использовании WeakReference для хранения ключей.<br> Таким образом, пара «ключ-значение» будет удалена из WeakHashMap, если на объект-ключ более не имеется сильных ссылок.<br><br>

В качестве примера использования такой структуры данных можно привести следующую ситуацию: допустим имеются объекты, которые необходимо расширить дополнительной информацией, при этом изменение класса этих объектов нежелательно либо невозможно. <br>В этом случае добавляем каждый объект в <b>WeakHashMap </b> в качестве ключа, а в качестве значения - нужную информацию. <br><br>Таким образом, пока на объект имеется сильная ссылка (либо мягкая), можно проверять хэш-таблицу и извлекать информацию. <br>Как только объект будет удален, то WeakReference для этого ключа будет помещен в ReferenceQueue и затем соответствующая запись для этой слабой ссылки будет удалена из <b>WeakHashMap</b>.]]>
    </string>
    <string name="coll_item_10">
    <![CDATA[   <b> HashMap </b>состоит из «корзин» (bucket).<br> С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов.<br> При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент.<br> Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. <br>Если в списке был найден элемент с таким же ключом, то он заменяется.]]>
    </string>
</resources>