<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="ser_item_1">
        <![CDATA[ <b>Сериализация (Serialization)</b> - процесс преобразования структуры данных в линейную последовательность байтов для дальнейшей передачи или сохранения.<br> Сериализованные объекты можно затем восстановить (десериализовать).<br><br>

В Java, согласно спецификации <b>Java Object Serialization</b> существует два стандартных способа сериализации: стандартная сериализация, через использование интерфейса <b>java.io.Serializable </b> и «расширенная» сериализация -<b> java.io.Externalizable</b>.<br><br>

<b>Сериализация</b> позволяет в определенных пределах изменять класс.<br> Вот наиболее важные изменения, с которыми спецификация<b> Java Object Serialization</b> может справляться автоматически:<br>

<b>1)</b>Добавление в класс новых полей;<br><br>
<b>2)</b>Изменение полей из статических в нестатические;<br><br>
<b>3)</b>Изменение полей из транзитных в нетранзитные.<br><br>
Обратные изменения (из нестатических полей в статические и из нетранзитных в транзитные) или удаление полей требуют определенной дополнительной обработки в зависимости от того, какая степень обратной совместимости необходима.]]>
    </string>
    <string name="ser_item_2">
    <![CDATA[    При использовании Serializable применяется алгоритм сериализации, который с помощью <b>рефлексии (Reflection API)</b> выполняет:<br>

<b>1)</b>Запись в поток метаданных о классе, ассоциированном с объектом (имя класса, идентификатор<b> SerialVersionUID</b>, идентификаторы полей класса);<br><br>
<b>2)</b>Рекурсивную запись в поток описания суперклассов до класса<b>java.lang.Object</b> (не включительно);<br><br>
<b>3)</b>Запись примитивных значений полей сериализуемого экземпляра, начиная с полей самого верхнего суперкласса;<br><br>
<b>4)</b>Рекурсивную запись объектов, которые являются полями сериализуемого объекта.<br><br>
При этом ранее сериализованные объекты повторно не сериализуются, что позволяет алгоритму корректно работать с циклическими ссылками.<br><br>

Для выполнения десериализации под объект выделяется память, после чего его поля заполняются значениями из потока.<br> Конструктор объекта при этом не вызывается.<br> Однако при десериализации будет вызван конструктор без параметров родительского несериализуемого класса, а его отсутствие повлечёт ошибку десериализации.<br><br>]]>
    </string>
    <string name="ser_item_3">
      <![CDATA[  Для изменения поведения необходимо реализовать интерфейс <b>java.io.Externalizable</b>, который позволяет применение пользовательской логики сериализации. <br>Способ сериализации и десериализации описывается в методах <b>writeExternal() и readExternal()</b>.<br> Во время десериализации вызывается конструктор без параметров, а потом уже на созданном объекте вызывается метод readExternal.<br><br>
Если у сериализуемого объекта реализован один из следующих методов, то механизм сериализации будет использовать его, а не метод по умолчанию :<br>
<b>1)writeObject()</b> - запись объекта в поток;<br><br>
<b>2)readObject()</b> - чтение объекта из потока;<br><br>
<b>3)writeReplace()</b> - позволяет заменить себя экземпляром другого класса перед записью;<br><br>
<b>4)readResolve()</b> - позволяет заменить на себя другой объект после чтения.<br><br>]]>
    </string>
    <string name="ser_item_4">
     <![CDATA[   Поля класса, помеченные модификатором <b>transient</b>, не сериализуются.<br><br>

Обычно в таких полях хранится промежуточное состояние объекта, которое, к примеру, проще вычислить.<br> Другой пример такого поля - ссылка на экземпляр объекта, который не требует сериализации или не может быть сериализован.]]>
    </string>
    <string name="ser_item_5">
        <![CDATA[  При стандартной сериализации поля, имеющие модификатор <b>static</b>, не сериализуются. <br> Соответственно, после десериализации это поле значения не меняет.<br> При использовании реализации <b>Externalizable </b>сериализовать и десериализовать статическое поле можно, но не рекомендуется этого делать, т.к. это может сопровождаться трудноуловимыми ошибками.<br><br>

Поля с модификатором<b> final</b> сериализуются как и обычные. <br> За одним исключением – их невозможно десериализовать при использовании <b>Externalizable</b>, поскольку <b>final</b> поля должны быть инициализированы в конструкторе, а после этого в<b> readExternal() </b> изменить значение этого поля будет невозможно.<br> Соответственно, если необходимо сериализовать объект с <b>final</b> полем необходимо использовать только стандартную сериализацию. ]]>
    </string>
    <string name="ser_item_6">
<![CDATA[ <b>serialVersionUID</b> используется для указания версии сериализованных данных.<br><br>

Когда мы не объявляем <b>serialVersionUID</b> в нашем классе явно, среда выполнения Java делает это за нас, но этот процесс чувствителен ко многим метаданным класса включая количество полей, тип полей, модификаторы доступа полей, интерфейсов, которые реализованы в классе и пр.<br><br>

Рекомендуется явно объявлять <b>serialVersionUID</b> т.к. при добавлении, удалении атрибутов класса динамически сгенерированное значение может измениться и в момент выполнения будет выброшено исключение <b>InvalidClassException</b>.]]>
    </string>
    <string name="ser_item_7">
<![CDATA[ Проблема в том что после десериализации мы получим другой объект. <br> Таким образом, сериализация дает возможность создать <b>Singleton </b>еще раз, что недопустимо.<br><br>
 Существует два способа избежать этого:<br>

<b>1)</b>Явный запрет сериализации.<br><br>
<b>2)</b>Определение метода с сигнатурой <b>(default/public/private/protected/) Object readResolve() throws ObjectStreamException</b>, назначением которого станет возврат замещающего объекта вместо объекта, на котором он вызван.]]>
    </string>
    <string name="ser_item_8">
      <![CDATA[  Если есть необходимость выполнения контроля за значениями десериализованного объекта, то можно использовать интерфейс<b> ObjectInputValidation</b> с переопределением метода </b>validateObject()</b>.<br><br>

        Так же существуют способы подписывания и шифрования, позволяющие убедиться, что данные не были изменены:<br>

<b>1)</b>с помощью описания логики в <b>writeObject() и readObject()</b>.<br><br>

<b>2)</b>поместить в оберточный класс <b>javax.crypto.SealedObject</b> и/или <b>java.security.SignedObject</b>.<br> Данные классы являются сериализуемыми, поэтому при оборачивании объекта в<b> SealedObject</b> создается подобие «подарочной упаковки» вокруг исходного объекта.<br> Для шифрования необходимо создать симметричный ключ, управление которым должно осуществляться отдельно.<br> <br>Аналогично, для проверки данных можно использовать класс <b>SignedObject</b>, для работы с которым также нужен симметричный ключ, управляемый отдельно.<br>]]>
    </string>
</resources>